/*
Navicat MySQL Data Transfer

Source Server         : YuanZzzblog
Source Server Version : 50720
Source Host           : localhost:3306
Source Database       : zzzblog

Target Server Type    : MYSQL
Target Server Version : 50720
File Encoding         : 65001

Date: 2018-01-08 00:37:31
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `main_article`
-- ----------------------------
DROP TABLE IF EXISTS `main_article`;
CREATE TABLE `main_article` (
  `aid` varchar(36) NOT NULL,
  `atitle` varchar(255) NOT NULL,
  `adate` varchar(20) NOT NULL,
  `aauther` varchar(20) DEFAULT NULL,
  `aoverview` varchar(50) DEFAULT NULL,
  `abody` text,
  `abodylink` varchar(255) DEFAULT NULL,
  `apiclink` varchar(255) DEFAULT NULL,
  `asource` varchar(255) DEFAULT NULL,
  `anew` tinyint(4) DEFAULT NULL,
  PRIMARY KEY (`aid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of main_article
-- ----------------------------
INSERT INTO `main_article` VALUES ('01', '一遍记住 Java 常用的八种排序算法与代码实现', '2017.12.29', 'breakingsword', '1.直接插入排序;经常碰到这样一类排序问题：把新的数据插入到已经排好的数据列中。将第一个数和第二', '1.直接插入排序\r\n经常碰到这样一类排序问题：把新的数据插入到已经排好的数据列中。\r\n1.	将第一个数和第二个数排序，然后构成一个有序序列\r\n2.	将第三个数插入进去，构成一个新的有序序列。\r\n3.	对第四个数、第五个数……直到最后一个数，重复第二步。\r\n如何写写成代码：\r\n1.	首先设定插入次数，即循环次数，for(int i=1;i<length;i++)，1个数的那次不用插入。\r\n2.	设定插入数和得到已经排好序列的最后一个数的位数。insertNum和j=i-1。\r\n3.	从最后一个数开始向前循环，如果插入数小于当前数，就将当前数向后移动一位。\r\n4.	将当前数放置到空着的位置，即j+1。\r\n代码实现如下：<br>\r\npublic void insertSort(int[] a){ \r\n        int length=a.length;//数组长度，将这个提取出来是为了提高速度。\r\n        int insertNum;//要插入的数\r\n        for(int i=1;i<length;i++){//插入的次数\r\n            insertNum=a[i];//要插入的数\r\n            int j=i-1;//已经排序好的序列元素个数\r\n            while(j>=0&&a[j]>insertNum){//序列从后到前循环，将大于insertNum的数向后移动一格\r\n                a[j+1]=a[j];//元素移动一格\r\n                j--;\r\n            }\r\n            a[j+1]=insertNum;//将需要插入的数放在要插入的位置。\r\n        }\r\n    }\r\n2.希尔排序\r\n对于直接插入排序问题，数据量巨大时。\r\n1.	将数的个数设为n，取奇数k=n/2，将下标差值为k的书分为一组，构成有序序列。\r\n2.	再取k=k/2 ，将下标差值为k的书分为一组，构成有序序列。\r\n3.	重复第二步，直到k=1执行简单插入排序。\r\n如何写成代码：\r\n1.	首先确定分的组数。\r\n2.	然后对组中元素进行插入排序。\r\n3.	然后将length/2，重复1,2步，直到length=0为止。\r\n代码实现如下：<br>\r\npublic  void sheelSort(int[] a){ \r\n        int d  = a.length; \r\n        while (d!=0) {\r\n            d=d/2; \r\n            for (int x = 0; x < d; x++) {//分的组数\r\n                for (int i = x + d; i < a.length; i += d) {//组中的元素，从第二个数开始\r\n                    int j = i - d;//j为有序序列最后一位的位数\r\n                    int temp = a[i];//要插入的元素\r\n                    for (; j >= 0 && temp < a[j]; j -= d) {//从后往前遍历。\r\n                        a[j + d] = a[j];//向后移动d位\r\n                    }\r\n                    a[j + d] = temp; \r\n                }\r\n            }\r\n        }\r\n    }\r\n3.简单选择排序\r\n常用于取序列中最大最小的几个数时。\r\n(如果每次比较都交换，那么就是交换排序；如果每次比较完一个循环再交换，就是简单选择排序。) \r\n1.	遍历整个序列，将最小的数放在最前面。\r\n2.	遍历剩下的序列，将最小的数放在最前面。\r\n3.	重复第二步，直到只剩下一个数。\r\n如何写成代码：\r\n1.	首先确定循环次数，并且记住当前数字和当前位置。\r\n2.	将当前位置后面所有的数与当前数字进行对比，小数赋值给key，并记住小数的位置。\r\n3.	比对完成后，将最小的值与第一个数的值交换。\r\n4.	重复2、3步。\r\n代码实现如下：<br>\r\n    public void selectSort(int[] a) {\r\n        int length = a.length; \r\n        for (int i = 0; i < length; i++) {//循环次数\r\n            int key = a[i]; \r\n            int position=i; \r\n            for (int j = i + 1; j < length; j++) {//选出最小的值和位置\r\n                if (a[j] < key) {\r\n                    key = a[j]; \r\n                    position = j; \r\n                }\r\n            }\r\n            a[position]=a[i];//交换位置\r\n            a[i]=key; \r\n        }\r\n    }\r\n4.堆排序\r\n对简单选择排序的优化。\r\n1.	将序列构建成大顶堆。\r\n2.	将根节点与最后一个节点交换，然后断开最后一个节点。\r\n3.	重复第一、二步，直到所有节点断开。\r\n代码实现如下：<br>\r\npublic  void heapSort(int[] a){ \r\n        System.out.println(\"开始排序\");\r\n        int arrayLength=a.length; \r\n        //循环建堆  \r\n        for(int i=0;i<arrayLength-1;i++){\r\n            //建堆  \r\n\r\n            buildMaxHeap(a,arrayLength-1-i); \r\n            //交换堆顶和最后一个元素  \r\n            swap(a,0,arrayLength-1-i); \r\n            System.out.println(Arrays.toString(a)); \r\n        }\r\n    }\r\n    private  void swap(int[] data, int i, int j) {\r\n        // TODO Auto-generated method stub  \r\n        int tmp=data[i]; \r\n        data[i]=data[j]; \r\n        data[j]=tmp; \r\n    }\r\n    //对data数组从0到lastIndex建大顶堆  \r\n    private void buildMaxHeap(int[] data, int lastIndex) {\r\n        // TODO Auto-generated method stub  \r\n        //从lastIndex处节点（最后一个节点）的父节点开始  \r\n        for(int i=(lastIndex-1)/2;i>=0;i--){\r\n            //k保存正在判断的节点  \r\n            int k=i; \r\n            //如果当前k节点的子节点存在  \r\n            while(k*2+1<=lastIndex){ \r\n                //k节点的左子节点的索引  \r\n                int biggerIndex=2*k+1; \r\n                //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在  \r\n                if(biggerIndex<lastIndex){ \r\n                    //若果右子节点的值较大  \r\n                    if(data[biggerIndex]<data[biggerIndex+1]){ \r\n                        //biggerIndex总是记录较大子节点的索引  \r\n                        biggerIndex++;\r\n                    }\r\n                }\r\n                //如果k节点的值小于其较大的子节点的值  \r\n                if(data[k]<data[biggerIndex]){ \r\n                    //交换他们  \r\n                    swap(data,k,biggerIndex); \r\n                    //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值  \r\n                    k=biggerIndex; \r\n                }else{\r\n                    break; \r\n                }\r\n            }\r\n        }\r\n    }\r\n5.冒泡排序\r\n一般不用。\r\n1.	将序列中所有元素两两比较，将最大的放在最后面。\r\n2.	将剩余序列中所有元素两两比较，将最大的放在最后面。\r\n3.	重复第二步，直到只剩下一个数。\r\n如何写成代码：\r\n1.	设置循环次数。\r\n2.	设置开始比较的位数，和结束的位数。\r\n3.	两两比较，将最小的放到前面去。\r\n4.	重复2、3步，直到循环次数完毕。\r\n代码实现如下：<br>\r\npublic void bubbleSort(int[] a){ \r\n        int length=a.length; \r\n        int temp; \r\n        for(int i=0;i<a.length;i++){\r\n            for(int j=0;j<a.length-i-1;j++){\r\n                if(a[j]>a[j+1]){ \r\n                    temp=a[j]; \r\n                    a[j]=a[j+1]; \r\n                    a[j+1]=temp; \r\n                }\r\n            }\r\n        }\r\n    }\r\n6.快速排序\r\n要求时间最快时。\r\n1.	选择第一个数为p，小于p的数放在左边，大于p的数放在右边。\r\n2.	递归的将p左边和右边的数都按照第一步进行，直到不能递归。\r\n代码实现如下：<br>\r\npublic static void quickSort(int[] numbers, int start, int end) {   \r\n    if (start < end) {   \r\n        int base = numbers[start]; // 选定的基准值（第一个数值作为基准值）   \r\n        int temp; // 记录临时中间值   \r\n        int i = start, j = end;   \r\n        do {   \r\n            while ((numbers[i] < base) && (i < end))   \r\n                i++;   \r\n            while ((numbers[j] > base) && (j > start))   \r\n                j--;   \r\n            if (i <= j) {   \r\n                temp = numbers[i];    \r\n                numbers[i] = numbers[j];   \r\n                numbers[j] = temp;   \r\n                i++;   \r\n                j--;   \r\n            }   \r\n        } while (i <= j);   \r\n        if (start < j)   \r\n            quickSort(numbers, start, j);   \r\n        if (end > i)   \r\n            quickSort(numbers, i, end);   \r\n    }   \r\n}\r\n7.归并排序\r\n速度仅次于快排，内存少的时候使用，可以进行并行计算的时候使用。\r\n1.	选择相邻两个数组成一个有序序列。\r\n2.	选择相邻的两个有序序列组成一个有序序列。\r\n3.	重复第二步，直到全部组成一个有序序列。\r\n代码实现如下：<br>\r\npublic static void mergeSort(int[] numbers, int left, int right) {   \r\n    int t = 1;// 每组元素个数   \r\n    int size = right - left + 1;   \r\n    while (t < size) {   \r\n        int s = t;// 本次循环每组元素个数   \r\n        t = 2 * s;   \r\n        int i = left;   \r\n        while (i + (t - 1) < size) {   \r\n            merge(numbers, i, i + (s - 1), i + (t - 1));   \r\n            i += t;   \r\n        }   \r\n        if (i + (s - 1) < right)   \r\n            merge(numbers, i, i + (s - 1), right);   \r\n    }   \r\n}   \r\nprivate static void merge(int[] data, int p, int q, int r) {   \r\n    int[] B = new int[data.length];    \r\n    int s = p;    \r\n    int t = q + 1;   \r\n    int k = p;   \r\n    while (s <= q && t <= r) {   \r\n        if (data[s] <= data[t]) {   \r\n            B[k] = data[s];   \r\n            s++;   \r\n        } else {   \r\n            B[k] = data[t];   \r\n            t++;   \r\n        }   \r\n        k++;   \r\n    }   \r\n    if (s == q + 1)   \r\n        B[k++] = data[t++];   \r\n    else  \r\n        B[k++] = data[s++];   \r\n    for (int i = p; i <= r; i++)   \r\n        data[i] = B[i];   \r\n}<br>\r\n8.基数排序\r\n用于大量数，很长的数进行排序时。\r\n1.	将所有的数的个位数取出，按照个位数进行排序，构成一个序列。\r\n2.	将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。\r\n代码实现如下：<br>\r\npublic void sort(int[] array) {\r\n        //首先确定排序的趟数;     \r\n        int max = array[0]; \r\n        for (int i = 1; i < array.length; i++) {\r\n            if (array[i] > max) {\r\n                max = array[i]; \r\n            }\r\n        }\r\n        int time = 0; \r\n        //判断位数;     \r\n        while (max > 0) {\r\n            max /= 10; \r\n            time++;\r\n        }\r\n        //建立10个队列;     \r\n        List<ArrayList> queue = new ArrayList<ArrayList>();\r\n        for (int i = 0; i < 10; i++) {\r\n            ArrayList<Integer> queue1 = new ArrayList<Integer>();\r\n            queue.add(queue1); \r\n        }\r\n        //进行time次分配和收集;     \r\n        for (int i = 0; i < time; i++) {\r\n            //分配数组元素;     \r\n            for (int j = 0; j < array.length; j++) {\r\n                //得到数字的第time+1位数;   \r\n                int x = array[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i); \r\n                ArrayList<Integer> queue2 = queue.get(x); \r\n                queue2.add(array[j]); \r\n                queue.set(x, queue2); \r\n            }\r\n            int count = 0;//元素计数器;     \r\n            //收集队列元素;     \r\n            for (int k = 0; k < 10; k++) {\r\n                while (queue.get(k).size() > 0) {\r\n                    ArrayList<Integer> queue3 = queue.get(k); \r\n                    array[count] = queue3.get(0); \r\n                    queue3.remove(0); \r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n    }', '', '${pageContext.request.contextPath }/img/paixu.jpg', 'http://www.jianshu.com/p/5e171281a387', '0');
INSERT INTO `main_article` VALUES ('02', 'Java核心技术点之集合框架', '2017.12.29', '搁浅-知乎', 'Java集合框架由Java类库的一系列接口、抽象类以及具体实现类组成。我们这里所说的集合就是把一组对', '概述\r\n\r\nJava集合框架由Java类库的一系列接口、抽象类以及具体实现类组成。我们这里所说的集合就是把一组对象组织到一起，\r\n然后再根据不同的需求操纵这些数据。集合类型就是容纳这些对象的一个容器。也就是说，最基本的集合特性就是把一组\r\n对象放一起集中管理。根据集合中是否允许有重复的对象、对象组织在一起是否按某种顺序等标准来划分的话，集合类型\r\n又可以细分为许多种不同的子类型。\r\nJava集合框架为我们提供了一组基本机制以及这些机制的参考实现，其中基本的集合接口是Collection接口，其他相关的\r\n接口还有Iterator接口、RandomAccess接口等。这些集合框架中的接口定义了一个集合类型应该实现的基本机制，Java类\r\n库为我们提供了一些具体集合类型的参考实现，根据对数据组织及使用的不同需求，只需要实现不同的接口即可。Java类\r\n库还为我们提供了一些抽象类，提供了集合类型功能的部分实现，我们也可以在这个基础上去进一步实现自己的集合类型\r\n。\r\nCollection接口\r\n迭代器\r\n我们先来看下这个接口的定义：\r\npublic interface Collection<E> extends Iterable<E>\r\n首先，它使用了一个类型参数；其次，它实现了Iterable<E>接口，我们再来看下Iterable<E>接口的定义：\r\npublic interface Iterable<T> {\r\n  Iterator<T> iterator();\r\n}\r\n我们可以看到这个接口只定义了一个方法，这个方法要求我们返回一个实现了Iterator<T>类型的对象，所以我们看下Iter\r\nator<T>的定义：\r\npublic interface Iterator<E> { \r\n  boolean hasNext(); \r\n  E next();\r\n  void remove();\r\n}<br>\r\n说到这里，我们简单地说一下迭代器（Iterator）这个东西。上面我们一共提到了两个和迭代器相关的接口：Iterable<E>\r\n接口和Iterator<E>接口，从字面意义上来看，前者的意思是“可迭代的”，后者的意思是“迭代器。所以我们可以这么理解\r\n这两个接口：实现了Iterable<E>接口的类是可迭代的；实现了Iterator<E>接口的类是一个迭代器。\r\n迭代器就是一个我们用来遍历集合中的对象的东西。也就是说，对于集合，我们不是像对原始类型数组那样通过数组索引\r\n来直接访问相应位置的元素，而是通过迭代器来遍历。这么做的好处是将对于集合类型的遍历行为与被遍历的集合对象分\r\n离，这样一来我们无需关心该集合类型的具体实现是怎样的。只要获取这个集合对象的迭代器, \r\n便可以遍历这个集合中的对象了。而像遍历对象的顺序这些细节，全部由它的迭代器来处理。现在我们来梳理一下前面提\r\n到的这些东西：首先，Collection接口实现了Iterable<E>接口，这意味着所有实现了Collection接口的具体集合类都是可\r\n迭代的。那么既然要迭代，我们就需要一个迭代器来遍历相应集合中的对象，所以Iterable<E>接口要求我们实现iterator\r\n方法，这个方法要返回一个迭代器对象。一个迭代器对象也就是实现了Iterator<E>接口的对象，这个接口要求我们实现ha\r\nsNext()、next()、remove()这三个方法。其中hasNext方法判断是否还有下一个元素（即是否遍历完对象了），next方法\r\n会返回下一个元素（若没有下一个元素了调用它会引起抛出一个NoSuchElementException异常），remove方法用于移除最\r\n近一次调用next方法返回的元素（若没有调用next方法而直接调用remove方法会报错）。我们可以想象在开始对集合进行\r\n迭代前，有个指针指向集合第一个元素的前面，第一次调用next方法后，这个指针会”扫过”第一个元素并返回它，调用has\r\nNext方法就是看这个指针后面还有没有元素了。也就是说这个指针始终指向刚遍历过的元素和下一个待遍历的元素之间。\r\n通常，迭代一个集合对象的代码是这个样子的：\r\nCollection<String> c = ...;\r\nIterator<String> iter = c.iterator();\r\nwhile (iter.hasNext()) {\r\n  String element = iter.next();\r\n  //do something with element\r\n}\r\n从Java SE 5.0开始，我们可以使用与以上代码段等价但是更加简洁的版本：\r\nfor (String element : c) {\r\n  //do something with element\r\n}\r\n上面我们提到过Iterator接口的remove方法必须在next方法返回一个元素后才能调用，这对Java类库中为我们提供的实现\r\n了Collection接口的类来说是这样的。当然我们可以通过自己定义一个实现Collection接口的集合类来改变这一默认行为\r\n（除非有充足的理由，否则最好不要这样做）。\r\nCollection接口\r\n我们先来看一下它的官方定义：\r\nThe root interface in the collection hierarchy. A collection represents a group of objects, known as its \r\nelements. Some collections allow duplicate elements and others do not. Some are ordered and others \r\nunordered. The JDK does not provide any direct implementations of this interface: it provides \r\nimplementations of more specific subinterfaces like Set and List. \r\n大概的意思就是：Collection接口是集合层级结构的根接口。一个集合代表了一组对象，这组对象被称为集合的元素。一\r\n些集合允许重复的元素而其他不允许；一些是有序的而一些是无序的。Java类库中并未提供任何对这个接口的直接实现，\r\n而是提供了对于它的更具体的子接口的实现（比如Set接口和List接口）。\r\n我们知道，接口是一组对需求的描述，那么让我们看看Collection接口提出了哪些需求。Collection接口中定义了以下方\r\n法：\r\nboolean add(E e) \r\n//向集合中添加一个元素，若添加元素后集合发生了变化就返回true，若没有发生变化，就返回false。(optional \r\noperation). \r\nboolean addAll(Collection<? extends E> c) //添加给定集合c中的所有元素到该集合中(optional operation). \r\nvoid clear() //(optional operation). \r\nboolean contains(Object o) //判断该集合中是否包含指定对象\r\nboolean containsAll(Collection<?> c) \r\nboolean equals(Object o) \r\nint hashCode()\r\nboolean isEmpty()\r\nIterator<E> iterator()\r\nboolean remove(Object o) //移除给定对象的一个实例（有的具体集合类型允许重复元素） (optional operation). \r\n\r\n\r\nboolean removeAll(Collection<?> c) //(optional operation). \r\n\r\nboolean retainAll(Collection<?> c) //仅保留给定集合c中的元素(optional operation). \r\n\r\nint size()\r\n\r\nObject[] toArray()\r\n\r\n<T> T[] toArray(T[] a) \r\n\r\n\r\n我们注意到有些方法后面注释中标注了“optional \r\noperation”，意思是Collection接口的实现类究竟需不需要实现这个方法视具体情况而定。比如有些具体的集合类型不允\r\n许向其中添加对象，那么它就无需实现add方法。我们可以看到，Collection对象必须实现的方法有：\r\ncontains方法、containsAll方法、isEmpty方法、iterator方法、size方法、两个toArray方法以及equals方法、hashCode\r\n方法，其中最后两个方法继承自Object类。\r\n\r\n\r\n我们来说一下两个toArray方法，它们的功能都是都是返回这个集合的对象数组。第二个方法接收一个arrayToFill参数，\r\n当这个参数数组足够大时，就把集合中的元素都填入这个数组（多余空间填null）；当arrayToFill不够大时，就会创建一\r\n个大小与集合相同，类型与arrayToFill相同的数组，并填入集合元素。\r\n\r\n\r\nCollection接口的直接子接口主要有三个：List接口、Set接口和Queue接口。下面我们对它们进行逐一介绍。\r\n\r\n\r\nList接口\r\n\r\n\r\n我们同样先看下它的官方定义：\r\n\r\n\r\nAn ordered collection (also known as a sequence). The user of this interface has precise control over \r\nwhere in the list each element is inserted. The user can access elements by their integer index (position \r\nin the list), and search for elements in the list.Unlike sets, lists typically allow duplicate elements. \r\nMore formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they \r\ntypically allow multiple null elements if they allow null elements at all. \r\n\r\n\r\n大概意思是：List是一个有序的集合类型（也被称作序列）。使用List接口可以精确控制每个元素被插入的位置，并且可\r\n以通过元素在列表中的索引来访问它。列表允许重复的元素，并且在允许null元素的情况下也允许多个null元素。\r\n\r\n\r\n我们再来看下它定义了哪些方法：\r\n\r\n\r\nListIterator<E> listIterator();\r\n\r\nvoid add(int i, E element); \r\n\r\nE remove(int i); \r\n\r\nE get(int i); \r\n\r\nE set(int i, E element); \r\n\r\nint indexOf(Object element); \r\n\r\n我们可以看到，列表支持对指定位置元素的读写与移除。我们注意到，上面有一个listIterator方法，它返回一个列表迭\r\n代器。我们来看一看ListIterator<E>接口都定义了哪些方法：\r\n\r\n\r\nvoid add(E e) //在当前位置添加一个元素\r\n\r\nboolean hasNext() //返回ture如果还有下个元素（在正向遍历列表时使用）\r\n\r\nboolean hasPrevious() //反向遍历列表时使用\r\n\r\nE next() //返回下一个元素并将cursor（也就是我们上文提到的”指针“）前移一个位置\r\n\r\nint nextIndex() //返回下一次调用next方法将返回的元素的索引\r\n\r\nE previous() //返回前一个元素并将cursor向前移动一个位置\r\n\r\nint previousIndex() //返回下一次调用previous方法将返回的元素的索引void remove() \r\n//从列表中移除最近一次调用next方法或previous方法返回的元素\r\n\r\n\r\nvoid set(E e) //用e替换最近依次调用next或previous方法返回的元素\r\n\r\nListIterator<E>是Iterator<E>的子接口，它支持像双向迭代这样更加特殊化的操作。综合以上，我们可以看到，List接\r\n口支持两种访问元素的方式：使用列表迭代器顺序访问或者使用get/set方法随机访问。\r\n\r\n\r\nJava类库中常见的实现了List<E>接口的类有：ArrayList， \r\nLinkedList，Stack，Vector，AbstractList，AbstractSequentialList等等。\r\n\r\n\r\nArrayList\r\n\r\n\r\nArrayList是一个可动态调整大小的数组，允许null类型的元素。我们知道，Java中的数组大小在初始化时就必须确定下来\r\n，而且一旦确定就不能改变，这会使得在很多场景下不够灵活。ArrayList很好地帮我们解决了这个问题，当我们需要一个\r\n能根据包含元素的多少来动态调整大小的数组时，那么ArrayList正是我们所需要的。\r\n\r\n\r\n我们先来看看这个类的常用方法：\r\n\r\n\r\nboolean add(E e) //添加一个元素到数组末尾\r\n\r\nvoid add(int index, E element) //添加一个元素到指定位置\r\n\r\nvoid clear()\r\n\r\nboolean contains(Object o) \r\n\r\n\r\nvoid ensureCapacity(int minCapacity) \r\n//确保ArrayList至少能容纳参数指定数目的对象，若有需要会增加ArrayList实例的容量。\r\n\r\n\r\nE get(int index) //返回指定位置的元素\r\n\r\nint indexOf(Object o) \r\n\r\nboolean isEmpty()\r\n\r\nIterator<E> iterator()\r\n\r\nListIterator<E> listIterator()\r\n\r\nE remove(int index) \r\n\r\nboolean remove(Object o) \r\n\r\nE set(int index, E element) \r\n\r\nint size()\r\n\r\n\r\n当我们插入了比较多的元素，导致ArrayList快要装满时，它会自动增长容量。ArrayList内部使用一个Object数组来存储\r\n元素，自动增长容量是通过创建一个新的容量更大的Object数组，并将元素从原Object数组复制到新Object数组来实现的\r\n。若要想避免这种开销，在知道大概会容纳多少数据时，我们可以在构造时指定好它的大小以尽量避免它自动增长的发生\r\n；我们也可以调用ensureCapacity方法来增加ArrayList对象的容量到我们指定的大小。ArrayList有以下三个构造器：\r\n\r\n\r\nArrayList()\r\n\r\nArrayList(Collection<? extends E> c) \r\n\r\nArrayList(int initialCapacity) //指定初始capacity，即内部Object数组的初始大小\r\n\r\n\r\nLinkedList类\r\n\r\n\r\nLinkedList类代表了一个双向链表，允许null元素。这个类同ArrayList一样，不是线程安全的。 \r\n这个类中主要有以下的方法：\r\n\r\n\r\nvoid addFirst(E element); \r\n\r\nvoid addLast(E element); \r\n\r\nE getFirst();\r\n\r\nE getLast();\r\n\r\nE removeFirst();\r\n\r\nE removeLast();\r\n\r\n这些方法的含义正如它们的名字所示。LinkedList作为List接口的实现类，自然包含了List接口中定义的add等方法。Link\r\nedList的add方法实现有以下两种：\r\n\r\n\r\nboolean add(E e) //把元素e添加到链表末尾\r\n\r\nvoid add(int index, E element) //在指定索引处添加元素\r\n\r\nLinkedList的一个缺陷在于它不支持对元素的高效随机访问，要想随机访问其中的元素，需要逐个扫描直到遇到符合条件\r\n的元素。只有当我们需要减少在列表中间添加或删除元素操作的代价时，可以考虑使用LinkedList。\r\n\r\n\r\nSet接口\r\n\r\n\r\nSet接口与List接口的重要区别就是它不支持重复的元素，至多可以包含一个null类型元素。Set接口定义的是数学意义上\r\n的“集合”概念。 Set接口主要定义了以下方法：\r\n\r\n\r\nboolean add(E e) \r\n\r\nvoid clear()\r\n\r\nboolean contains(Object o) \r\n\r\nboolean isEmpty()\r\n\r\nboolean equals(Object obj) \r\n\r\nIterator<E> iterator()\r\n\r\nboolean remove(Object o) \r\n\r\nboolean removeAll(Collection<?> c) \r\n\r\nint size()\r\n\r\nObject[] toArray()\r\n\r\n<T> T[] toArray(T[] a) \r\n\r\nSet接口并没有显式要求其中的元素是有序或是无序的，它有一个叫做SortedSet的子接口，这个接口可以用来实现对Set元\r\n素的排序，SortedSet还有叫做NavigableSet的子接口，这个接口定义的方法可以在有序Set中进行查找和遍历。Java类库\r\n中实现了Set接口的类主要有：AbstractSet，HashSet，TreeSet，EnumSet，LinkedHashSet等等。其中，HashSet与TreeSe\r\nt都是AbstractSet的子类。那么，为什么Java类库要提供AbstractSet这个抽象类呢？答案是为了让我们在自定义实现Set\r\n接口的类时不必“从零开始”，AbstractSet这个抽象类已经为我们实现了Set接口中的一些常规方法，而一些灵活性比较强\r\n的方法可以由我们自己来定义，我们只需要继承AbstractSet这个抽象类即可。类似的抽象类还有很多，比如我们上面提到\r\n的实现了List接口的AbstractList抽象类就是LinkedList和ArrayList的父类。Java官方文档中提到，HashSet和TreeSet分\r\n别基于HashMap和TreeMap实现（我们在后面会简单介绍HashMap和TreeMap），他们的区别在于Set<E>接口是一个对象的集\r\n（数学意义上的”集合“），Map<K, V>是一个键值对的集合。而且由于它们分别是对Set<E>和Map<K, \r\nV>接口的实现，相应添加与删除元素的方法也取决于具体接口的定义。\r\n\r\n\r\nQueue接口\r\n\r\n\r\nQueue接口是对队列这种数据结构的抽象。一般的队列实现允许我们高效的在队尾添加元素，在队列头部删除元素（First \r\nin, First \r\nout)。Queue<E>接口还有一个名为Deque的子接口，它允许我们高效的在队头或队尾添加/删除元素，实现了Deque<E>的接\r\n口的集合类即为双端队列的一种实现（比如LinkedList就实现了Deque接口）。Queue接口定义了以下方法：\r\n\r\n\r\nboolean add(E e) //添加一个元素到队列中，若队列已满会抛出一个IllegalStateException异常\r\n\r\nE element() //获取队头元素\r\n\r\nboolean offer(E e) //添加一个元素到队列中，若队列已满返回false\r\n\r\nE peek() //获取队头元素，若队列为空返回null\r\n\r\nE poll() //返回并移除队头元素，若队列为空返回null\r\n\r\nE remove() //返回并移除队头元素\r\n\r\n我们注意观察下上面的方法：add与offer，element与peek，remove与poll看似是三对儿功能相同的方法。它们之间的重要\r\n区别在于前者若操作失败会抛出一个异常，后者若操作失败会从返回值体现出来（比如返回false或null），我们可以根据\r\n具体需求调用它们中的前者或后者。\r\n\r\n\r\n实现Queue接口的类主要有：AbstractQueue， ArrayDeque， \r\nLinkedList，PriorityQueue，DelayQueue等等。关于它们具体的介绍可参考官方文档或相关的文章。\r\n\r\n\r\nMap接口\r\n\r\n\r\n我们先来看下它的定义：\r\n\r\n\r\nAn object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one \r\nvalue.The Map interface provides three collection views, which allow a map’s contents to be viewed as a \r\nset of keys, collection of values, or set of key-value mappings. The order of a map is defined as the \r\norder in which the iterators on the map’s collection views return their elements. Some map \r\nimplementations, like the TreeMap class, make specific guarantees as to their order; others, like the \r\nHashMap class, do not. \r\n\r\n\r\n大概意思是这样的：一个把键映射到值的对象被称作一个Map对象。映射表不能包含重复的键，每个键至多可以与一个值关\r\n联。Map接口提供了三个集合视图（关于集合视图的概念我们下面会提到）：键的集合视图、值的集合视图以及键值对的集\r\n合视图。一个映射表的顺序取决于它的集合视图的迭代器返回元素的顺序。一些Map接口的具体实现（比如TreeMap）保证\r\n元素有一定的顺序，其它一些实现（比如HashMap）则不保证元素在其内部有序。\r\n\r\n\r\n也就是说，Map接口定义了一个类似于“字典”的规范，让我们能够根据键快速检索到它所关联的值。我们先来看看Map接口\r\n定义了哪些方法：\r\n\r\n\r\nvoid clear()\r\n\r\nboolean containsKey(Object key) //判断是否包含指定键\r\n\r\nboolean containsValue(Object value) //判断是否包含指定值\r\n\r\nboolean isEmpty()\r\n\r\nV get(Object key) //返回指定键映射的值\r\n\r\nV put(K key, V value) //放入指定的键值对\r\n\r\nV remove(Object key) \r\n\r\nint size()\r\n\r\nSet<Map.Entry<K,V>> entrySet()\r\n\r\nSet<K> keySet()\r\n\r\nCollection<V> values()\r\n\r\n\r\n后三个方法在我们下面介绍集合视图时会具体讲解。\r\n\r\n\r\nMap接口的具体实现类主要有：AbstractMap，EnumMap，HashMap，LinkedHashMap，TreeMap。HashTable。\r\n\r\n\r\nHashMap\r\n\r\n\r\n我们看一下HashMap的官方定义：\r\n\r\n\r\nHashMap<K, \r\nV>是基于哈希表这个数据结构的Map接口具体实现，允许null键和null值。这个类与HashTable近似等价，区别在于HashMap\r\n不是线程安全的并且允许null键和null值。由于基于哈希表实现，所以HashMap内部的元素是无序的。HashMap对与get与pu\r\nt操作的时间复杂度是常数级别的（在散列均匀的前提下）。对HashMap的集合视图进行迭代所需时间与HashMap的capacity\r\n（bucket的数量）加上HashMap的尺寸（键值对的数量）成正比。因此，若迭代操作的性能很重要，不要把初始capacity设\r\n的过高（不要把load factor设的过低）。\r\n\r\n\r\n有两个因素会影响一个HashMap对象的性能：intial capacity（初始容量）和load factor（负载因子）。intial \r\ncapacity就是HashMap对象刚创建时其内部的哈希表的“桶”的数量（请参考哈希表的定义）。load factor等于maxSize / \r\ncapacity，也就是HashMap所允许的最大键值对数与桶数的比值。增大load \r\nfactor可以节省空间但查找一个元素的时间会增加，减小load \r\nfactor会占用更多的存储空间，但是get与put的操作会更快。当HashMap中的键值对数量超过了maxSize（即load \r\nfactor与capacity的乘积），它会再散列，再散列会重建内部数据结构，桶数（capacity）大约会增加到原来的两倍。\r\n\r\n\r\nHashMap默认的load \r\nfactor大小为0.75，这个数值在时间与空间上做了很好的权衡。当我们清楚自己将要大概存放多少数据时，也可以自定义l\r\noad factor的大小。\r\n\r\n\r\nHashMap的构造器如下：\r\n\r\n\r\nHashMap()\r\nHashMap(int initialCapacity) \r\n\r\n\r\nHashMap(int initialCapacity, float loadFactor) \r\nHashMap(Map<? extends K,? extends V> m) //创建一个新的HashMap，用m的数据填充\r\n\r\n\r\n常用方法如下：\r\n\r\n\r\nvoid clear()\r\n\r\nboolean containsKey(Object key) \r\n\r\nboolean containsValue(Object value) \r\n\r\nV get(Object key) \r\n\r\nV put(K key, V value) \r\n\r\nboolean isEmpty()\r\n\r\nV remove(Object key) \r\n\r\nint size()\r\n\r\nCollection<V> values()\r\n\r\nSet<Map.Entry<K,V>> entrySet()\r\n\r\nSet<K> keySet()\r\n\r\n它们的功能都很直观，更多的使用细节可以参考Java官方文档，这里就不贴上来了。这里简单地提一下WeakHashMap，它与\r\nHashMap的区别在于，存储在其中的key是“弱引用”的，也就是说，当不再存在对WeakHashMap中的键的外部引用时，相应的\r\n键值对就会被回收。关于WeakHashMap和其他类的具体使用方法及注意事项，大家可以参考官方文档。下面我们来简单地介\r\n绍下另一个Map接口的具体实现——TreeMap。\r\n\r\n\r\nTreeMap\r\n\r\n\r\n它的官方定义是这样的：\r\n\r\n\r\nTreeMap<K, V>一个基于红黑树的Map接口实现。TreeMap中的元素的有序的，排序的依据是存储在其中的键的natural \r\nordering（自然序，也就是数字从小到大，字母的话按照字典序）或者根据在创建TreeMap时提供的Comparator对象，这取\r\n决于使用了哪个构造器。TreeMap的containsKey, get, put和remove操作的时间复杂度均为log(n)。\r\n\r\n\r\nTreeMap有以下构造器：\r\n\r\n\r\nTreeMap() //使用自然序对其元素进行排序\r\n\r\nTreeMap(Comparator<? super K> comparator) //使用一个比较器对其元素进行排序\r\n\r\nTreeMap(Map<? extends K,? extends V> m) //构造一个与映射表m含有相同元素的TreeMap，用自然序进行排列\r\n\r\nTreeMap(SortedMap<K,? extends V> m) //构造一个与有序映射表m含有相同元素及元素顺序的TreeMap\r\n\r\n\r\n它的常见方法如下：\r\n\r\n\r\nMap.Entry<K,V> ceilingEntry(K key) //返回一个最接近且大于等于指定key的键值对。\r\n\r\nK ceilingKey(K key) \r\n\r\nvoid clear()\r\n\r\nComparator<? super K> comparator() //返回使用的比较器，若按自然序则返回null\r\n\r\nboolean containsKey(Object key) \r\n\r\nboolean containsValue(Object value) \r\n\r\nNavigableSet<K> descendingKeySet() //返回一个包含在TreeMap中的键的逆序的NavigableSet视图\r\n\r\nNavigableMap<K,V> descendingMap()\r\n\r\nSet<Map.Entry<K,V>> entrySet()\r\n\r\nMap.Entry<K,V> firstEntry() //返回键最小的键值对\r\n\r\nMap.Entry<K,V> floorEntry(K key) //返回一个最接近指定key且小于等于它的键对应的键值对\r\n\r\nK floorKey(K key) \r\n\r\nV get(Object key) \r\n\r\nSet<K> keySet()\r\n\r\nMap.Entry<K,V> lastEntry() //返回与最大的键相关联的键值对\r\n\r\nK lastKey()\r\n\r\n\r\n建议大家先了解下红黑树这个数据结构的原理及实现（可参考算法（第4版） \r\n(豆瓣)），然后再去看官方文档中关于这个类的介绍，这样学起来会事半功倍。\r\n\r\n\r\n最后再简单地介绍下NavigableMap<K, V>这个接口：\r\n\r\n\r\n实现了这个接口的类支持一些navigation \r\nmethods，比如lowerEntry（返回小于指定键的最大键所关联的键值对），floorEntry（返回小于等于指定键的最大键所关\r\n联的键值对），ceilingEntry（返回大于等于指定键的最小键所关联的键值对）和higerEntry（返回大于指定键的最小键\r\n所关联的键值对）。一个NavigableMap支持对其中存储的键按键的递增顺序或递减顺序的遍历或访问。NavigableMap<K, \r\nV>接口\r\n还定义了firstEntry、pollFirstEntry、lastEntry和pollLastEntry等方法，以准确获取指定位置的键值对。\r\n\r\n\r\n总的来说，NavigableMap<K, \r\nV>接口正如它的名字所示，支持我们在映射表中”自由的航行“，正向或者反向迭代其中的元素并获取我们需要的指定位置\r\n的元素。TreeMap实现了这个接口。\r\n\r\n\r\n视图（View）与包装器\r\n\r\n\r\n下面我们来解决一个上面遗留的问题，也就是介绍一下集合视图的概念。Java中的集合视图是用来查看集合中全部或部分\r\n数据的一个”窗口“，只不过通过视图我们不仅能查看相应集合中的元素，对视图的操作还可能会影响到相应的集合。通过\r\n使用视图可以获得其他的实现了Map接口或Collection接口的对象。比如我们上面提到的TreeMap和HashMap的keySet()方法\r\n就会返回一个相应映射表对象的视图。也就是说，keySet方法返回的视图是一个实现了Set接口的对象，这个对象中又包含\r\n了一系列键对象。\r\n\r\n\r\n轻量级包装器\r\n\r\n\r\nArrays.asList会发挥一个包装了Java数组的集合视图（实现了List接口）。请看以下代码：\r\n\r\n\r\npublic static void main(String[] args) {\r\n\r\n  String[] strings = {\"first\", \"second\", \"third\"};\r\n\r\n  List<String> stringList = Arrays.asList(strings); \r\n\r\n  String s1 = stringList.get(0); \r\n\r\n  System.out.println(s1); \r\n\r\n  stringList.add(0, \"new first\");\r\n\r\n\r\n}\r\n以上代码会编译成功，但是在运行时会抛出一个UnsupportedOperationException异常，原因是调用了改变列表大小的add\r\n方法。Arrays.asList方法返回的封装了底层数组的集合视图不支持对改变数组大小的方法（如add方法和remove方法）的\r\n调用（但是可以改变数组中的元素）。实际上，这个方法调用了以下方法：\r\n\r\n\r\nCollections.nCopies(n, anObject); \r\n\r\n\r\n这个方法会返回一个实现了List接口的不可修改的对象。这个对象包含了n个元素（anObject）。\r\n\r\n\r\n子范围\r\n\r\n\r\n我们可以为很多集合类型建立一个称为子范围（subrange）的集合视图。例如以下代码抽出group中的第10到19个元素（从\r\n0开始计数）组成一个子范围：\r\n\r\n\r\nList subgroup = group.subList(10, 20); //group为一个实现了List接口的列表类型\r\n\r\n\r\nList接口所定义的操作都可以应用于子范围，包括那些会改变列表大小的方法，比如以下方法会把subgroup列表清空，同\r\n时group中相应的元素也会从列表中移除：\r\n\r\n\r\nsubgroup.clear();\r\n\r\n对于实现了SortedSet<E>接口的有序集或是实现了SortedMap<K, \r\nV>接口的有序映射表，我们也可以为他们创建子范围。SortedSet接口定义了以下三个方法：\r\n\r\n\r\nSortedSet<E> subSet(E from, E to); \r\n\r\nSortedSet<E> headSet(E to); \r\n\r\nSortedSet<E> tailSet(E from); \r\n\r\nSortedMap也定义了类似的方法：\r\n\r\n\r\nSortedMap<K, V> subMap(K from, K to); \r\n\r\nSortedMap<K, V> headMap(K to); \r\n\r\nSortedMap<K, V> tailMap(K from); \r\n\r\n不可修改的视图\r\n\r\n\r\nCollections类中的一些方法可以返回不可修改视图（unmodifiable views)：\r\n\r\n\r\nCollections.unmodifiableCollection\r\n\r\nCollections.unmodifiableList\r\n\r\nCollections.unmodifiableSet\r\n\r\nCollections.unmodifiableSortedSet\r\n\r\nCollections.unmodifiableMap\r\n\r\nCollections.unmodifiableSortedMap\r\n\r\n同步视图\r\n\r\n\r\n若集合可能被多个线程并发访问，那么我们就需要确保集合中的数据不会被破坏。Java类库的设计者使用视图机制来确保\r\n常规集合的线程安全。比如，我们可以调用以下方法将任意一个实现了Map接口的集合变为线程安全的：\r\n\r\n\r\nMap<String, Integer> map = Collections.synchronizedMap(new HashMap<String, Integer>());\r\n\r\n被检验视图\r\n\r\n\r\n我们先看一下这段代码：\r\n\r\n\r\nArrayList<String> strings = new ArrayList<String>();\r\n\r\nArrayList rawList = strings; \r\n\r\nrawList.add(new Date());\r\n\r\n\r\n在以上代码的第二行，我们把泛型数组赋值给了一个原始类型数组，这通常只会产生一个警告。而第三行我们往rawList中\r\n添加一个Date对象时，并不会产生任何错误。因为rawList内部存储的实际上是Object对象，而任何对象都可以转换为Obje\r\nct对象。那么我们怎么避免这一问题呢，请看以下代码：\r\n\r\n\r\nArrayList<String> strings = new ArrayList<String>();\r\n\r\nList<String> safeStrings = Collections.checkedList(strings, String.class); \r\n\r\nArrayList rawList = safeStrings; \r\n\r\nrawList.add(new Date()); //Checked list throws a ClassCastException\r\n\r\n\r\n在上面，我们通过包装strings得到一个被检验视图safeStrings。这样在尝试添加非String对象时，便会抛出一个ClassCa\r\nstException异常。\r\n\r\n\r\n集合视图的本质\r\n\r\n\r\n集合视图本身不包含任何数据，它只是对相应接口的包装。集合视图所支持的所有操作都是通过访问它所关联的集合类实\r\n例来实现的。我们来看看HashMap的keySet方法的源码：\r\n\r\npublic Set<K> keySet() {\r\n\r\n  Set<K> ks; \r\n\r\n  return (ks = keySet) == null ? (keySet = new KeySet()) : ks; \r\n\r\n} \r\n\r\n\r\nfinal class KeySet extends AbstractSet<K> {\r\n  public final int size() { \r\n    return size; \r\n  }\r\n  public final void clear() { \r\n    HashMap.this.clear(); \r\n  }\r\n  public final Iterator<K> iterator() { \r\n    return new KeyIterator(); \r\n  }\r\n  public final boolean contains(Object o) { \r\n    return containsKey(o); \r\n  }\r\n  public final boolean remove(Object key) {\r\n    return removeNode(hash(key), key, null, false, true) != null;\r\n  }\r\n  public final Spliterator<K> spliterator() {\r\n    return new KeySpliterator<>(HashMap.this, 0, -1, 0, 0);\r\n  }\r\n  public final void forEach(Consumer<? super K> action) {\r\n    Node<K,V>[] tab;\r\n    if (action == null) throw new NullPointerException();\r\n    if (size > 0 && (tab = table) != null) {\r\n      int mc = modCount;\r\n      for (int i = 0; i < tab.length; ++i) {\r\n        for (Node<K,V> e = tab[i]; e != null; e = e.next) \r\n\r\n          action.accept(e.key); \r\n\r\n        }\r\n\r\n        if (modCount != mc) throw new \r\nConcurrentModificationException();\r\n\r\n      }\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n我们可以看到，实际上keySet()方法返回一个内部final类KeySet的实例。我们可以看到KeySet类本身没有任何实例变量。\r\n我们再看KeySet类定义的size()实例方法，它的实现就是通过直接返回HashMap的实例变量size。还有clear方法，实际上\r\n调用的就是HashMap对象的clear方法。\r\n\r\n\r\nkeySet方法能够让你直接访问到Map的键集，而不需要复制数据或者创建一个新的数据结构，这样做往往比复制数据到一个\r\n新的数据结构更加高效。考虑这样一个场景：你需要把一个之前创建的数组传递给一个接收List参数的方法，那么你可以\r\n使用Arrays.asList方法返回一个包装了数组的视图（这需要的空间复杂度是常数级别的），而不用创建一个新的ArrayLis\r\nt再把原数组中的数据复制过去。\r\n\r\n\r\nCollections类\r\n\r\n\r\n我们要注意到Collections类与Collection接口的区别：Collection是一个接口，而Collections是一个类（可以看做一个\r\n静态方法库）。下面我们看一下官方文档对Collections的描述：\r\n\r\n\r\nCollections类包含了大量用于操作或返回集合的静态方法。它包含操作集合的多态算法，还有包装集合的包装器方法等等\r\n。这个类中的所有方法在集合或类对象为空时均会抛出一个NullPointerException。\r\n\r\n\r\n关于Collections类中的常用方法，我们上面已经做了一些介绍，更加详细的介绍大家可以参考Java官方文档。\r\n', '${pageContext.request.contextPath }/articleBody?aid=02', null, 'https://zhuanlan.zhihu.com/p/27756586', '1');
INSERT INTO `main_article` VALUES ('03', '由 HashMap 引申出的技术深度讨论', '2017.12.30', '咕咚-知乎', '在面试中，HashMap 是一个被问到概率很大的一个知识点，因为它本身是一种非常好的数据结构，而且', '在面试中，HashMap 是一个被问到概率很大的一个知识点，因为它本身是一种非常好的数据结构，而且从 HashMap \r\n中可以引申出数组、链表、红黑树、扩容、优化、线程同步等诸多考点，所以很多的面试官都会从 HashMap \r\n开始考察一个人的 Java 水平。\r\n好文推荐\r\n所以有必要认真研究下 HashMap \r\n的具体原理，这里我极力推荐一篇16年的文章，出自美团点评的公众号-美团点评技术团队。Java8系列之重新认识HashMa\r\np\r\n这篇文章非常棒，把 HashMap \r\n的方方面面都讲了个遍，同时还不缺深度。读罢，对作者这种刨根问底的技术态度也敬佩有加。\r\n现在的很多面试中，面试官对技术深度的要求都开始变得高起来，如果你只是知道一些表面的东西，是显然不行的。所以\r\n对待技术，深度是一定要要有的，而且这个东西很容易考察。\r\n那么一般的面试官会怎么考察你的技术深度呢？这里就以 HashMap 为例来看看面试官怎么一步步来跟你聊 HashMap 的。\r\n问题来了\r\n首先问一个简单的问题作为开始。\r\n1、HashMap 和 Hashtable 的区别？\r\n前者线程不同步，在单线程条件下操作性能较好，后者线程同步，在多线程条件下可以正确操作，不会发生多线程下的操\r\n作问题。\r\n2、如何使 HashMap 线程同步？\r\n使用 Collections 的 util 方法 synchronizedMap 就可以让原本不支持线程同步的 HashMap 支持线程同步。\r\n答到这一步，说明你对技术细节掌握的还不错，接着问\r\n3、Collections 的 synchronizedMap 方法是怎么实现让原本不线程同步的 map 支持线程同步的？\r\n如果你看过源码，你会这样回答\r\n\"Collections 内部有一个实现了 Map 接口的 SynchronizedMap 内部类，这是一个实现线程同步的 map \r\n类，具体线程同步就是在所有的方法实现中都使用 synhronized 块达到线程同步，不过具体的方法实现统统使用 \r\nsynchronizedMap 方法传递进去 map 来完成，如下所示\r\n    @Override\r\n    public boolean remove(Object key, Object value) {\r\n        synchronized (mutex) {\r\n            return m.remove(key, value); \r\n        }\r\n    }\r\n可以看到 SynchronizedMap 在实现 remove 方法时最终是用传递进来的 map, 只不过加了 synchronized \r\n块，其实这就是典型的装饰设计。\"\r\n如果你没有看过源码，面试官可能会问题，如果让你自己实现，你怎么实现，其实这里要实现线程同步，终归需要使用 \r\nsynchronized 来完成，所以思路还是通过这种装饰设计。当然这里如果看过源码你会说的很轻松。\r\n这时如果回答的没问题，面试官想进一步增加深度，可能会问下一个问题。\r\n4、如果需要在多线程条件下使用 HashMap，除了使用 Collections 的 util \r\n方法，还有什么方法可以更简单的做到线程同步？\r\n如果此时你能提到 ConcurrentHashMap，那么面试官已经觉得你对 HashMap 的了解有一定的深度。接着再来一个问题。\r\n5、ConcurrentHashMap 是怎么做并发控制的，相比 Hashtable 有什么优势吗? \r\n此时，你心想『 我擦？还有完没完，这要问到地老天荒啊... 』\r\n如果你此时说『 ConcurrentHashMap 引入了分段锁的机制，该机制对并发控制做了优化 \r\n』，那么面试官会点点头，心想『 这小伙还不错~ 』，当然他可能会继续追问，\r\n6、你跟我讲讲什么是分段锁？\r\n这时即使你对这个概念不清楚，你如实回答，面试官对你印象也不会很差，因为你对一个技术点的了解已经有了相当的深\r\n度。当然如果你能就分段锁可以展开跟面试官大聊一番，那最好不过了，不过能问这个问题的，面试官本身应该对这些东\r\n西有一定的了解，否则他也不会问到这个问题。\r\n到此为止，一个问题算是问完了，同时你也可以看到从一个基本的知识点，可以向下衍生出多少问题。\r\n当然我说的这些上面那个链接大都提到了，而且文中汇集的知识点更多更全，建议认真阅读，当你读懂了，关于 \r\nHashMap 的一些基本问题大都能答个八九不离十。\r\n如何考察一个 Android 面试者的能力水平？知乎上 @扔物线 前辈有一个不错的回答，你也可以顺便看看。\r\n总结\r\n其实写完文章加上最近的一些经历，个人对技术深度有了一个更清晰的认识，而且自己在很多技术点上确实也有很多不足\r\n，不过反过来说，让一个人对每一个技术点都要求有很深的了解也是不现实的。\r\n但是如果你在简历上写了你的技能，就表示你对他了解或者掌握，所以你要对自己的简历负责。一般有水平的面试官都会\r\n从简历中提取一些技术点，然后像上面那样一点点深入，逐步的考察面试者对知识的掌握程度。这也在印证另一个道理：\r\n简历上写自己会的东西或者掌握了的东西，不要粘贴复制别人的模板，否则在面试时会很惨。\r\n另外。我还是觉得在实际工作中，面对一个实际具体的问题，应该保持啃透的态度，而不是能通过就行的态度。比如最近\r\n你在做应用的启动优化，那么你就应该先详细了解应用的启动过程，以及启动时长统计，然后通过打点或者工具去分析应\r\n用启动过程。总之每个步骤自己都应该非常了然于胸。\r\n\r\n当然，说到容易做到难，更多的道理还需要自己动手才会产生好的结果。\r\n本文原创发布于公众号 大侠咕咚，欢迎扫码关注更多原创文章。\r\naHR0cDovL3dlaXhpbi5xcS5jb20vci9ha1Rad2VyRWw3Zm9yYTZpOXhGNA== (二维码自动识别)', '${pageContext.request.contextPath }/articleBody?aid=03', '${pageContext.quest.contextPath}/img/HashMap.jpg', 'https://zhuanlan.zhihu.com/p/27325430', '0');
INSERT INTO `main_article` VALUES ('04', '学习JavaScript，有哪些好的博客或者网站', '2017.12.31', '@Tw93-知乎', '其实对于JavaScript的学习，我觉得最重要的还是多练习，多看书，多做小项目，那些前端博客或者网', '	\r\n其实对于JavaScript的学习，我觉得最重要的还是多练习，多看书，多做小项目，那些前端博客或者网站一般是给你\r\n带来一种思维，或者说对于前端的思考方式，假如看了以后不去练习，其实可能作用不是很大。\r\n\r\n1.	系统学习JavaScript，可能看书效果好一点，推荐好书，★代表深浅度： \r\n•	JavaScript DOM编程艺术 （第2版）★\r\n•	JavaScript高级程序设计（第3版）★★\r\n•	锋利的jQuery★★\r\n•	高性能JavaScript★★★\r\n•	JavaScript语言精粹★★★\r\n•	JavaScript权威指南★★★\r\n•	编写可维护的JavaScript★★★\r\n•	JAVASCRIPT语言精髓与编程实践★★★\r\n•	Effective Javascript★★★\r\n•	Secrets of the JavaScript Ninja★★★\r\n•	JavaScript模式★★★\r\n•	JavaScript设计模式★★★★\r\n•	基于MVC的JavaScript Web富应用开发★★★\r\n//每次买了新书都特别兴奋，所以说多买书吧。\r\n每个想提高JavaScript能力的人都应该有一本《JavaScript权威指南》。这是一本字典式的读物，虽然不适合初学者，但\r\n是可以把它当作你的第二本JavaScript书籍。\r\n\r\n增加\r\n1.	首先增加一个重要的内容：JavaScript | MDN 为什么首先推荐它呢？曾任Mozilla公司首席首席技术官的Brendan \r\nEich是JavaScript主要创造者与架构师。 这个是 Mozilla 开发者网络社区的学习资料，比W3school \r\n要好，对于疏通JavaScript很有益处。 \r\n2.	想了解ECMAScript 6 入门的, 阮老师的这个网站不要错过。 \r\n3.	居然忘记InfoQ这个网站 ，InfoQ - 促进软件开发领域知识与创新的传播，这是他的JavaScript频道。 \r\nInfoQ是一家国际技术媒体，虽然网站不是很漂亮，但是内容大于样式。 \r\n网站的JavaScript频道知识很多，很多国际上的新知识。有JavaScript &gt; 新闻 &gt; 第1页 || JavaScript &gt; \r\n文章 &gt; 第1页 || JavaScript &gt; 迷你书 &gt; 第1页 || JavaScript &gt; 演讲 &gt; 第1页 ||JavaScript \r\n&gt; 访谈 &gt; 第1页  \r\n4.	Div.IO: \r\n最近发现了一个高质量的前端社区，聚集了很多各大公司前端牛人，里面的干货很多，不过这个网站需要注册码才可以注\r\n册，但是假如仅仅是阅读上面的文章，不需要注册码也是可以的。见图：页面很简洁，还有阅读效果很好。 \r\n5.	前端乱炖, 最专业的前端技术内容社区 \r\n这个网站是我去得很多的一个网站，里面有一个专栏模块，用于展示各种原创文章，原创翻译文章，知识性比较强，内容\r\n比较专业和系统。 这个网站的特点是更新较多，同时大大也很多。 \r\n6.	CNode：Node.js专业中文社区 \r\n想学习Nodejs吗？那么这个网站很建议你去，而且里面的人很友善，或者说彼此交流学习的氛围超级好，这个社区是由 \r\n@朴灵\r\n他们创办的。 网站精华栏目见截图： \r\n7.	技术文章 FEX 做最专业的前端 百度FEX一直很牛逼，FEX 是百度「Web 前端研发部」的内部名称，其中 FE 是 \r\nFront End 的缩写，X \r\n代表他们不仅关注前端技术，还更重视全端及全栈的能力。开源项目很多。很多思想值得我们学习。 \r\n8.	JavaScript on Smashing Magazine \r\n接着来一个国外的，里面新东西很多，不过全部是英文的，有点考验你的英语阅读能力。（这个不符合题目要求，但还是\r\n推荐一下） \r\n9.	Issues • xufei/blog • GitHub \r\n@徐飞\r\n是我所知，国内研究angular很透彻的一个人，github \r\n博客上面关于angular的精华分享很多，文章讲的很透彻，每一次他出文章，一般都会认真读一遍，很受益的 \r\n10.	夏天的森林 - 博客园 \r\n夏天的森林，博客形式主要以“连载”为主，不得不说，你的花一些时间去学习，看过之后能够对于JavaScript的某一些方\r\n面有很深的理解： \r\n11.	汤姆大叔 - 博客园 应该很多搞前端的人都看过汤姆大叔的书，他的博客园里面东西很多很多，值得常去看看。\r\n12.	JavaScript 秘密花园 \r\n超级推荐这个,JavaScript秘密花园是一个不断更新的文档，主要关心JavaScript一些古怪用法。 \r\n对于如何避免常见的错误，难以发现的问题，以及性能问题和不好的实践给出建议， \r\n初学者可以籍此深入了解JavaScript的语言特性。 \r\n13.	http://www.codewars.com/r/gAMm9Q \r\n我又来推荐这个代码的打怪升级网站，主要你可以用它来练习你的JavaScript，对于提高你的JavaScript编程能力是很重\r\n要的。同时对于你英语能力的提高是很重要的。 \r\n14.	前端网址导航 当你看到这里来了，证明这个才是好东西，简历ctrl+d，前端导航网站，分类不错，小东西很多。\r\n', '${pageContext.request.contextPath }/articleBody?aid=04', null, 'https://www.zhihu.com/question/19651401', '1');
INSERT INTO `main_article` VALUES ('05', '成为 Java 高手的25个学习要点', '2017.12.31', '搁浅-知乎', '想要精通Java，成为Java高手，需要不断的学习和积累。本文给出了Java学习过程中需要注意的25', '想要精通Java，成为Java高手，需要不断的学习和积累。本文给出了Java学习过程中需要注意的25个学习目标，希望可以\r\n给您带来帮助。\r\n\r\n1.你需要精通面向对象分析与设计(OOA/OOD)、涉及模式(GOF，J2EEDP)以及综合模式。你应该了解UML，尤其是class、ob\r\nject、interaction以及statediagrams。\r\n\r\n2.你需要学习Java语言的基础知识以及它的核心类库(collections、serialization、streams、networking、multithrea\r\nding、reflection、event、handling、NIO、localization以及其他)。\r\n\r\n3.你应该了解JVM、classloaders、classreflect以及垃圾回收的基本工作机制等。你应该有能力反编译一个类文件并且\r\n明白一些基本的汇编指令。\r\n\r\n4.如果你将要写客户端程序，你需要学习Web的小应用程序(applet)，必需掌握GUI设计的思想和方法，以及桌面程序的SW\r\nING、AWT、SWT。你还应该对UI部件的JavaBEAN组件模式有所了解。JavaBEANS也被应用在JSP中以把业务逻辑从表现层中\r\n分离出来。\r\n\r\n5.你需要学习Java数据库技术，并且会使用至少一种persistence/ORM构架，例如Hibernate、JDO、CocoBase、TopLink、\r\nInsideLiberator(国产JDO红工厂软件)或者iBatis。\r\n\r\n6.你还应该了解对象关系的阻抗失配的含义以及它是如何影响业务对象与关系型数据库的交互，和它的运行结果。还需要\r\n掌握不同的数据库产品运用，比如Oracle、MySQL、SQL server。\r\n\r\n7. 你需要学习Servlets、JSP，以及JSTL(StandardTagLibraries)和可以选择的第三方TagLibraries。\r\n\r\n8.你需要熟悉主流的网页框架，例如JSF、Struts、Tapestry、Cocoon、WebWork，以及他们下面的涉及模式，如MVC/MODE\r\nL2。\r\n\r\n9.你需要学习如何使用及管理Web服务器，例如tomcat、resin、Jrun，并且知道如何在其基础上扩展和维护Web程序。\r\n\r\n10. 你需要学习分布式对象以及远程API，例如RMI和RMI/IIOP。\r\n\r\n11. 你需要掌握各种流行中间件技术标准和与Java结合实现，比如Tuxedo、CROBA，当然也包括JavaEE本身。\r\n\r\n12.你需要学习最少一种的XMLAPI，例如JAXP(JavaAPIforXMLProcessing)、JDOM(JavaforXMLDocumentObjectModel)、DOM\r\n4J或JAXR(JavaAPIforXMLRegistries)。\r\n\r\n13.你应该学习如何利用Java的API和工如具来构建WebService。例如JAX-RPC(JavaAPIforXML/RPC)、SAAJ(SOAPwithAttac\r\nh\r\nmentsAPIforJava)、JAXB(JavaArchitectureforXMLBinding)、JAXM(JavaAPIforXMLMessaging)、JAXR(JavaAPIforXMLReg\r\ni\r\nstries)或者JWSDP(JavaWebServicesDeveloperPack)。\r\n\r\n14.你需要学习一门轻量级应用程序框架，例如Spring、PicoContainer、Avalon，以及它们的IoC/DI风格(setter，const\r\nructor，interfaceinjection)。\r\n\r\n15. \r\n你需要熟悉不同的J2EE技术，例如JNDI(JavaNamingandDirectoryInterface)、JMS(JavaMessageService)、JTA/JTS(Java\r\nTransactionAPI/JavaTransactionService)、JMX(JavaManagementeXtensions)，以及JavaMail。\r\n\r\n16.你需要学习企业级JavaBeans(EJB)以及它们的不同组件模式：Stateless/StatefulSessionBeans、EntityBeans(包含B\r\nean-ManagedPersistence[BMP]或者Container-ManagedPersistence[CMP]和它的EJB-QL)，或者Message-DrivenBeans(MDB\r\n)。\r\n\r\n17.你需要学习如何管理与配置一个J2EE应用程序服务器，如WebLogic、JBoss等，并且利用它的附加服务，例如簇类，连\r\n接池以及分布式处理支援。你还需要了解如何在它上面封装和配置应用程序并且能够监控、调整它的性能。\r\n\r\n18.你需要熟悉面向方面的程序设计以及面向属性的程序设计(这两个都被很容易混淆的缩写为AOP)，以及他们的主流Java\r\n规格和执行。例如AspectJ和AspectWerkz。\r\n\r\n19. 你需要熟悉对不同有用的API和frame \r\nwork等来为你服务。例如Log4J(logging/tracing)、Quartz(scheduling)、JGroups(networkgroupcommunication)、JCac\r\nhe(distributedcaching)、Lucene(full-textsearch)、JakartaCommons等等。\r\n\r\n20.你应该熟练掌握一种JavaIDE例如sunOne、netBeans、IntelliJIDEA或者Eclipse。(有些人更喜欢VI或EMACS来编写文\r\n件。随便你用什么了) \r\n\r\n21.Java(精确的说是有些配置)是冗长的，它需要很多的人工代码(例如EJB)，所以你需要熟悉代码生成工具，例如XDocle\r\nt。\r\n\r\n22. 你需要熟悉一种单元测试体系(JNunit)，并且学习不同的生成、部署工具(Ant，Maven)。\r\n\r\n23.你需要熟悉一些在Java开发中经常用到的软件工程过程。例如RUP(RationalUnifiedProcess)andAgilemethodologies\r\n。\r\n\r\n24. 你还需要紧跟Java发展的步伐，比如现在可以深入的学习Webwork2.0。\r\n\r\n25.你必需要对实际项目的开发流程有所了解，至少要有两个有实际应用价值的项目，而不是练习项目!因为现在企业看重\r\n的是你有没有实际的开发经验，真正开发经验的体现就是你做的项目，也就是有实际应用的项目! \r\n\r\n', null, null, 'https://zhuanlan.zhihu.com/p/27759448', '0');
INSERT INTO `main_article` VALUES ('06', '关于非计算机专业出生，能做好Java吗？', '2017.12.31', 'Java-知乎', 'IT行业与其它行业相比，它的技术变更更加快速，可能每天都会有新的技术出现，你每天也都会接受到新的名词', '快速学习，多阅读，多实践”\r\nIT行业与其它行业相比，它的技术变更更加快速，可能每天都会有新的技术出现，你每天也都会接受到新的名词、新的技\r\n术、新的架构体系。身处在这个变化如此之快的行业，快速学习的能力变得非常重要。比如一个新技术出来，你的老板可\r\n能需要你用一个月的时间用这个新技术完成一个项目，一般这种情况下，你最多只有一周时间完成对这个技术基本入门，\r\n后面就是一边用一边学。\r\n\r\n说到学习能力，我需要特别强调一点的是英文的阅读能力。其实作为程序猿，英语能力是不可或缺的。毕竟计算机这整套\r\n体系都是老外创造出来的，所以我们在学习新技术的时候面对的大部分都是英文文档。这个时候，就特别需要我们有一个\r\n良好的英语阅读的能力，这样我们才能更好的快速掌握相关的技术信息。\r\n学习新技能的时候，除了阅读文档，另外我们需要做的就是多动手实践，多写代码。很多学员在交流的时候都会跟我反应\r\n一个问题，就是说跟着老师的视频会写代码，但是自己写就写不出来。其实写代码也是一个熟能生巧的事情，代码敲的多\r\n了自然而然的就会写了，如果写不出来说明代码还写得不够多。反复练习，积累达到一定的量就会有一些写代码的灵感，\r\n进而就会产生一种质变。总而言之就是，纸上得来终觉浅，绝知此事要躬行。\r\n\r\n注重基础，抓住核心\r\n”前面提到IT领域技术更新很快，我们需要有一个快速学习的能力。对于一个初学者来说，面对纷繁复杂的各种技术，很多\r\n人都会一时手足无措，不知道从哪里下手，很多跨专业的同学都会遇到这个问题。我这边需要说的是，虽然这个领域技术\r\n繁多，新的技术也都层出不穷，但是有一句古话，万变不离其宗，这句话就是强调我们需要去抓住所谓的那个宗，也就是\r\n我们所指的技术的基础与核心。\r\n\r\n作为非计算机专业的同学，我不建议大家一开始就去学习Java或者C语言，还有所谓的各种框架。很多非计算机专业的同学\r\n可能会通过自学或者社会上的一些所谓的快速培训机构学习编程，在短暂的学习后就能够自己做出一两个简单的项目，甚\r\n至能够胜任普通工作中的一般任务。但是由于没有对计算机专业知识进行系统性的学习，对计算机基础知识缺乏了解，所\r\n以在遇到一些涉及到计算机底层的一些东西的时候就会不知所措。比如计算机网络通信、数据库的设计规范、数据结构的\r\n优化、多进程多线程编程等等，这些都是非计算机专业的同学欠缺的知识。就好像盖房子，在没有打牢固地基的情况下就\r\n开始添砖加瓦，最后轰然倒塌是必然的。\r\n\r\n作为跨专业的同学，建议大家先学习一些计算机相关的知识，这里推荐一些书单。如果大家能把这几本书都能够完整的自\r\n学一遍，我想也就可以算是计算机入门了。\r\n《计算机体系机构》\r\n了解最基础的计算机硬件知识\r\n《计算机操作系统》\r\n了解整个操作系统的实现和编程环境\r\n《编译原理》《计算机网络》\r\n了解编程语言的原理和网络原理\r\n《数据结构与算法》\r\n\r\n了解编程中常用的数据结构与经典算法\r\n这里打个比喻，如果大家先将计算机专业的知识体系建立起来了，就好像先练就了一身九阳神功，后面再学任务其它武功\r\n就是易如反掌，这样才有可能做到我之前提到的快速学习。\r\n勤写技术博客，与牛人多交流\r\n\r\n”写技术博客是一种可以快速提高的方法，我们可以分享自己总结的一些经验，也可以分享自己的体会。一样东西在你大脑\r\n里，并不代表你已经掌握了，如果你能说给别人听，或者用文字表达出来，那才算真正掌握了。\r\n大家在刚刚写技术博客的时候不要担心自己分享的东西太low，只要你认为是有价值，都可以写出来，这不仅可以给别人提\r\n供知识，同时也能够整理自己的思路，有时候还可以得到网上朋友的意见和反馈，跟大家一起交流。\r\n在IT这个领域，你会发现周围有很多技术牛人，他们都身怀绝杀武功，通常他们都很低调，低调到你都很难发现。如果你\r\n发现周围或者网上有这样的同事或者朋友，就可以多跟他做一些技术交流和讨论，在这个交流和讨论的过程中你会学习到\r\n他思考问题的思路和方法，同时也会加深对知识的理解，这样也是一种快速提高很好的方法。\r\n主动寻找项目经验\r\n\r\n”最后当我们内功都已经练好准备要出去面试的时候，经常会被问到项目经验的问题。因为作为一个成熟的企业，它肯定希\r\n望招到的人能够快速为公司产生价值，这里不管是对于校招或者社招都是一样。但是对于大多数跨专业的同学，这就是非\r\n常大的难题。这里给大家支两招：\r\n\r\n| 开源项目\r\n最简单直接获取项目经验的方法就是参与到开源项目的开发中，我们可以先到开源中国或者github上找一些不是那么复杂\r\n的开源项目开始练手，当然如果你自己有创意，可以自己建立一个开源项目，动手实践。\r\n\r\n| 无偿工作\r\n有时候可能开源项目的需求不是那么明确，跟实际的项目还是有一定差距；那我想说的是大家可以去找一些无偿工作的机\r\n会，普通的企业通常可能并不想雇佣经验少或没有经验的人，但是非盈利的机构通常会愿意雇佣这样的人；只要有合适的\r\n项目，最后能够获得项目经验，锻炼自己成长，有没有报酬都是无所谓的。\r\n世上无难事只怕有心人。我想对于非计算机专业的同学，只要能够按照一定的方法坚持学习，动手实践，时刻保持对知识\r\n的追求和渴望，有朝一日一定可以成为这个行业的佼佼者。\r\n就像上文所说的那样，Java学习的道路上除了自学外，另一个好方法就是找牛人交流，借助他人的经历获取高效的学习方\r\n法和快速进阶的方式。\r\n', null, null, 'https://zhuanlan.zhihu.com/p/27744352', '0');
INSERT INTO `main_article` VALUES ('07', '装饰者模式(Decorator)', '2018.1.5', 'YuanZzz', '是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比', '装饰者模式，又叫修饰模式(Decorator)\r\n\r\n是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活\r\n，这样可以给某个对象而不是整个类添加一些功能。\r\n\r\n通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在\r\n将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用\r\n原来的类中的方法。修饰类必须和原来的类有相同的接口。\r\n\r\n修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。\r\n\r\n当有几个相互独立的功能需要扩充时，这个区别就变得很重要。在有些面向对象的编程语言中，类不能在运行时被创建，\r\n通常在设计的时候也不能预测到有哪几种功能组合。这就意味着要为每一种组合创建一个新类。相反，修饰模式是面向运\r\n行时候的对象实例的,这样就可以在运行时根据需要进行组合。一个修饰模式的示例是JAVA里的Java I/O Streams的实现。\r\n\r\n例如，一个窗口系统中的窗口，允许这个窗口内容滚动，我们希望给它添加水平或垂直滚动条。假设窗口通过“Window”类\r\n实例来表示，并且假设它没有添加滚动条功能。我们可以创建一个子类“ScrollingWindow”来提供，或者我们可以创建一个\r\nScrollingWindowDecorator来为已存在的Window对象添加这个功能。在这点上，只要是解决方案就可以了。 \r\n现在我们假设希望选择给我们的窗口添加边框，同样，我们的原始Window类不支持。ScrollingWindow子类现在会造成一个\r\n问题，因为它会有效的创建一种新的窗口。如果我们想要给所有窗口添加边框，我们必须创建WindowWithBorder和Scrolli\r\nngWindowWithBorder子类。显然，这个问题由于被添加类而变得更糟了。对于修饰模式，我们简单的创建一个新类Bordere\r\ndWindowDecorator，在运行时，我们能够使用ScrollingWindowDecorator或BorderedWindowDecorator或两者结合来修饰已\r\n存在的窗口。 \r\n一个修饰能够被应用的另一个好例子是当有需要根据某套规则或者几个平行的规则集（不同的用户凭据等）限制访问对象\r\n的属性或方法时。\r\n\r\n一个对象的属性或方法按照某组规则或几个并行规则(不同用户证书等)需要限制访问时，在这种情况下，不是在原始对象\r\n中实现访问控制而是在他的使用中不变或不知道任何限制，并且他被包装在一个访问控制修饰对象中，这个对象能够对允\r\n许的原始对象的接口子集服务。\r\n\r\n以下为Java代码示例\r\n\r\npublic interface ICar {\r\n	void move();\r\n}\r\n\r\n/*\r\n * 普通的车类\r\n */\r\nclass Car implements ICar{\r\n\r\n	@Override\r\n	public void move() {\r\n		System.out.println(\"能在陆地上跑！\");\r\n	}\r\n	\r\n}\r\n\r\n/*\r\n * 高级车\r\n */\r\n class SuperCar implements ICar {\r\n	 \r\n	 protected ICar car ;\r\n	\r\n	 public SuperCar(ICar car){\r\n		 this.car = car;\r\n	 }\r\n	 @Override\r\n	public void move() {\r\n		car.move();\r\n	}\r\n	 \r\n }\r\n \r\n /*\r\n  * 扩展功能\r\n  */\r\nclass FlyCar extends SuperCar{\r\n	\r\n	public FlyCar(ICar car){\r\n		super(car);\r\n	}\r\n	\r\n	public void fly(){\r\n		System.out.println(\"能在天上飞！\");\r\n	}\r\n	@Override\r\n	public void move() {\r\n		super.move();\r\n		fly();\r\n	}\r\n}\r\n\r\nclass WaterCar extends SuperCar{\r\n	\r\n	public WaterCar(ICar car){\r\n		super(car);\r\n	}\r\n	\r\n	public void swim(){\r\n		System.out.println(\"能在水里游！\");\r\n	}\r\n	@Override\r\n	public void move() {\r\n		super.move();\r\n		swim();\r\n	}\r\n}\r\n\r\nmain方法测试：\r\n\r\npublic static void main(String[] args) {\r\n		ICar car = new Car();\r\n		System.out.print(\"普通车的功能--->\");\r\n		car.move();\r\n		\r\n		System.out.println(\"\\n增加新的功能--->飞行\");\r\n		FlyCar flyCar = new FlyCar(car);\r\n		flyCar.move();\r\n		\r\n		System.out.println(\"\\n增加新的功能--->游泳\");\r\n		WaterCar waterCar = new WaterCar(flyCar);\r\n		waterCar.move();\r\n	}\r\n	\r\n结果：\r\n		普通车的功能--->能在陆地上跑！\r\n\r\n		增加新的功能--->飞行\r\n		能在陆地上跑！\r\n		能在天上飞！\r\n\r\n		增加新的功能--->游泳\r\n		能在陆地上跑！\r\n		能在天上飞！\r\n		能在水里游！', null, null, null, '1');
INSERT INTO `main_article` VALUES ('08', '动态代理(DynamicProxy)', '2018.1.5', 'YuanZzz', '动态代理就是在运行时生成一个类，这个类会实现你指定的一组接口，而这个类没有.java文件，是在运行', '动态代理(DynamicProxy)\r\n\r\n1、什么是动态代理\r\n动态代理就是在运行时生成一个类，这个类会实现你指定的一组接口，而这个类没有.java文件，是在运行时生成的，你也不用去关心它是什么类型的，你只需要知道它实现了哪些接口即可。\r\n\r\n　　平常实现一个接口需要写一个具体的实现类，而动态代理技术能够在运行期间动态的生成实现指定接口的实现类对象，底层使用的反射原理。在框架中经常使用，例如：Struts1、Struts2、Spring和Hibernate等等。学习动态代理可以更好的理解框架内部的原理。\r\n\r\n2、动态代理的用途\r\n动态代理作为代理模式的一种扩展形式，广泛应用于框架（尤其是基于AOP的框架）的设计与开发，动态代理的用途与装饰模式很相似，就是为了对某个对象进行增强。所有使用装饰者模式的案例都可以使用动态代理来替换。\r\n\r\n　　在java类加载器中也应用了代理模式，例如我们自己写的Person类，一定是存放到CLASSPATH中，那么一定是由系统类加载器来加载。当系统类加载器来加载类时，它首先把加载的任务交给扩展类加载去，如果扩展类加载器加载成功了，那么系统类加载器就不会再去加载。这就是代理模式了！\r\n\r\n　　代理模式保证了JDK中的类一定是由引导类加载器加载的！这就不会出现多个版本的类，这也是代理模式的好处。\r\n\r\n3、动态代理各个角色分析\r\n　抽象角色：声明真实对象和代理对象的共同接口,这样一来在任何可以使用目标对象的地方都可以使用代理对象。\r\n\r\n　　代理角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象，同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。\r\n\r\n　　真实角色：定义了代理对象所代表的目标对象，代理角色所代表的真实对象，是我们最终要引用的对象,定义了代理对象所代表的目标对象。\r\n\r\n4、动态代理优点\r\n　减少编程的工作量：假如需要实现多种代理处理逻辑，只要写多个代理处理器就可以了，无需每种方式都写一个代理类。\r\n\r\n　　系统扩展性和维护性增强，程序修改起来也方便多了(一般只要改代理处理器类就行了)。\r\n\r\n　　做方法的增强，可以在不修改源码的情况下，增强一些方法，实现无侵入式的代码扩展。\r\n\r\n代码示例：\r\npackage com.Proxy.DynamicProxy;\r\n//抽象接口\r\npublic interface Star {\r\n	/*\r\n	 * 面谈\r\n	 */\r\n	void confer();\r\n	/*\r\n	 * 签合同\r\n	 */\r\n	void signContract();\r\n	/*\r\n	 * 订票\r\n	 */\r\n	void bookTicket();\r\n	/*\r\n	 * 唱歌\r\n	 */\r\n	void sing();\r\n}\r\n\r\npackage com.Proxy.DynamicProxy;\r\n/**\r\n * 真实角色\r\n *\r\n */\r\npublic class RealStar implements Star {\r\n\r\n	@Override\r\n	public void confer() {\r\n		System.out.println(\"realStar.confer()\");\r\n	}\r\n\r\n	@Override\r\n	public void signContract() {\r\n		System.out.println(\"realStar.signContract()\");\r\n	}\r\n\r\n	@Override\r\n	public void bookTicket() {\r\n		System.out.println(\"realStar.bookTicket()\");\r\n\r\n	}\r\n\r\n	@Override\r\n	public void sing() {\r\n		System.out.println(\"realStar.sing()\");\r\n\r\n	}\r\n\r\n}\r\n\r\npackage com.Proxy.DynamicProxy;\r\n\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * 动态代理类，继承  java.lang.reflect.InvocationHandler 接口\r\n * @author Yuan\r\n *\r\n */\r\npublic class StarHandler implements InvocationHandler{\r\n\r\n	private Star realStar;\r\n	\r\n	public StarHandler(Star star){\r\n		this.realStar = star;\r\n	}\r\n	\r\n	/**\r\n	 * Object 为传入的对象\r\n	 * method 为要调用的方法\r\n	 * Object[] 为传入的参数\r\n	 */\r\n	@Override\r\n	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n		Object obj = null;\r\n		\r\n		System.out.println(\"真正的方法执行前..\");\r\n		\r\n		if(method.getName().equals(\"sing\")){\r\n			obj = method.invoke(realStar, args);	//激活realStar的方法，并带入参数 args\r\n		}\r\n		\r\n		System.out.println(\"真正的方法执行后..\");\r\n		\r\n		return obj;\r\n	}\r\n\r\n}\r\n\r\nmain方法测试：\r\n\r\npublic static void main(String[] args) {\r\n		\r\n		Star realStar = new RealStar();\r\n		StarHandler handler = new StarHandler(realStar);\r\n		\r\n		/*\r\n		 *	类加载器\r\n		 *	接口\r\n		 *	代理类对象\r\n		 */\r\n		Star proxy = (Star)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()\r\n									, new Class[]{Star.class}\r\n										, handler);\r\n		\r\n		proxy.sing();\r\n	}\r\n', null, null, null, '1');
INSERT INTO `main_article` VALUES ('09', '享元模式(Flyweight Pattern)', '2018.1.5', 'YuanZzz', '享元模式（英语：FlyweightPattern）是一种软件设计模式。它使用共享物件，用来尽可能减少', '享元模式（英语：FlyweightPattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。\r\n\r\n使用场景：\r\n\r\n如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销的时候就可以考虑是否可以使用享元模式。\r\n\r\n例如,如果发现某个对象的生成了大量细粒度的实例，并且这些实例除了几个参数外基本是相同的，如果把那些共享参数移到类外面，在方法调用时将他们传递进来，就可以通过共享大幅度单个实例的数目。\r\n\r\n/**\r\n * 享元模式（FlyWeight） \r\n * \r\n * 内存属于稀缺资源，不要随便浪费，如果有很多个完全相同或相似的对象，\r\n * 我们可以通过享元模式，节省内存。\r\n * \r\n * 享元模式以共享的方式高效地支持大量细粒度对象的重用\r\n * \r\n * 享元对象能做到共享的关键是区分了内部状态和外部状态。\r\n * #内部状态：可以共享，不会随环境变化而改变\r\n * #外部状态：不可以共享，会随环境的变化而变化\r\n * \r\n * 享元模式的实现：\r\n * -FlyweightFactory享元工厂类\r\n * 	创建并管理享元对象，享元池一般设计成键值对\r\n * \r\n * -FlyWeight抽象享元类\r\n * 	通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象\r\n * 	的内部状态，设置外部状态。\r\n * \r\n * -ConcreteFlyWeight具体享元类\r\n * 	为内部状态提供成员变量进行存储\r\n * \r\n * -UnsharedConcreteFlyWeight非共享享元类\r\n * 	不能共享的子类可以设置为非共享享元类\r\n *\r\n */\r\n \r\n\r\n	main方法测试：\r\n\r\n	public static void main(String[] args) {\r\n		ChessFlyWeight chess1 = ChessFlyweightFactory.getChess(\"黑色\");\r\n		ChessFlyWeight chess2 = ChessFlyweightFactory.getChess(\"黑色\");\r\n		System.out.println(chess1==chess2);\r\n		\r\n		chess1.display(new Coordinate(10,10));\r\n		chess2.display(new Coordinate(20,10));\r\n	}\r\n	\r\n接口：\r\n\r\npackage com.FlyWeight;\r\n\r\npublic interface ChessFlyWeight {\r\n	String getColor();\r\n	void display(Coordinate c);\r\n}\r\n\r\nclass ConcreteChess implements ChessFlyWeight{\r\n	\r\n	private String color;\r\n	\r\n	public ConcreteChess(String color){\r\n		this.color = color;\r\n	}\r\n	\r\n	\r\n	@Override\r\n	public String getColor() {\r\n		return color;\r\n	}\r\n\r\n	@Override\r\n	public void display(Coordinate c) {\r\n		System.out.println(\"棋子颜色:\"+color);\r\n		System.out.println(\"棋子位置:\"+c.getX()+\"----\"+c.getY());\r\n		\r\n	}\r\n	\r\n}\r\n\r\n工厂：\r\n\r\npackage com.FlyWeight;\r\n/**\r\n * -FlyweightFactory享元工厂类\r\n * 	创建并管理享元对象，享元池一般设计成键值对\r\n */\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class ChessFlyweightFactory {\r\n	\r\n	private static Map<String, ChessFlyWeight> map = new HashMap<String, ChessFlyWeight>();\r\n	\r\n	public static ChessFlyWeight getChess(String color){\r\n		\r\n		if(map.get(color)==null){\r\n			map.put(color, new ConcreteChess(color));\r\n		}\r\n		return map.get(color);\r\n	}\r\n}\r\n\r\nbean：\r\npackage com.FlyWeight;\r\n/**\r\n *	棋子的位置 \r\n *\r\n */\r\npublic class Coordinate {\r\n	private int x,y;\r\n	\r\n	public Coordinate(int x, int y){\r\n		this.x = x;\r\n		this.y = y;\r\n	}\r\n\r\n	public int getX() {\r\n		return x;\r\n	}\r\n\r\n	public void setX(int x) {\r\n		this.x = x;\r\n	}\r\n\r\n	public int getY() {\r\n		return y;\r\n	}\r\n\r\n	public void setY(int y) {\r\n		this.y = y;\r\n	}\r\n	\r\n	\r\n}', null, null, null, '1');

-- ----------------------------
-- Table structure for `main_message`
-- ----------------------------
DROP TABLE IF EXISTS `main_message`;
CREATE TABLE `main_message` (
  `mid` varchar(38) NOT NULL,
  `mname` varchar(20) NOT NULL,
  `mdate` varchar(255) NOT NULL,
  `mcontent` text NOT NULL,
  PRIMARY KEY (`mid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of main_message
-- ----------------------------
INSERT INTO `main_message` VALUES ('01', '博主', '2018-1-2', 'Happy New Year!\r\n新年快乐！');
INSERT INTO `main_message` VALUES ('02', '路人甲', '2019-1-5', '欢迎XX！');
INSERT INTO `main_message` VALUES ('bc8a4dae-5d29-4a08-aee3-9d21d9b70d52', '袁霄', '2018-01-06', '你好！');
